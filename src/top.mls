open Interface
node declare_once(port : int; direction : int) returns (out : int)
var v : bool;
let
  out = Interface.declare_io(port, direction, v);
  v = true fby false
tel

node count_true returns (y : int)
var v : int;
let
  y = (v + 1);
  v = 0 fby y
tel

node counter(period : int) returns (c : bool)
var do_tick : bool; y : int; v : bool; v_1 : int; v_2 : bool; v_3 : bool;
    v_4 : int; v_5 : int; v_6 : int;
let
  c = do_tick;
  y = if v_3 then 0 else v_6;
  v_6 = if do_tick then 0 else v_5;
  v_5 = (v_4 + 1);
  v_4 = pre y;
  v_3 = true fby false;
  do_tick = if v then false else v_2;
  v_2 = (v_1 >= period);
  v_1 = pre y;
  v = true fby false
tel

node led(period : int; pin : int; toggle : bool) returns (out : bool)
var s : int; change : bool; statee : bool; i : int; v : bool; v_7 : bool;
    v_8 : bool; v_9 : bool; v_10 : bool; v_11 : bool; v_12 : bool;
    v_13 : int; v_14 : int; v_15 : bool; v_16 : bool; v_17 : bool;
let
  out = if change then v_16 else v_17;
  v_17 = false fby out;
  v_16 = not(v_15);
  v_15 = false fby out;
  i = if v_12 then s else v_14;
  v_14 = if change then v_13 else 0;
  v_13 = Interface.change_pin_state(pin, statee);
  v_12 = true fby false;
  statee = if v then true else v_11;
  v_11 = if toggle then v_10 else false;
  v_10 = if change then v_8 else v_9;
  v_9 = pre statee;
  v_8 = not(v_7);
  v_7 = pre statee;
  v = true fby false;
  change = counter(period);
  s = declare_once(pin, 1)
tel

node xor_node(i_1 : bool; i_2 : bool) returns (o : bool)
var v : bool; v_18 : bool; v_19 : bool; v_20 : bool;
let
  o = (v_18 or v_20);
  v_20 = (i_2 & v_19);
  v_19 = not(i_1);
  v_18 = (i_1 & v);
  v = not(i_2)
tel

node toggle_node(inp : bool) returns (outp : bool)
var last_val : bool; v : bool; v_21 : bool; v_22 : bool; v_23 : bool;
    v_24 : bool; v_25 : bool; v_26 : bool;
let
  outp = if v_22 then false else v_26;
  v_26 = xor_node(v_23, v_25);
  v_25 = (inp & v_24);
  v_24 = not(last_val);
  v_23 = pre outp;
  v_22 = true fby false;
  last_val = if v then false else v_21;
  v_21 = pre inp;
  v = true fby false
tel

node led_control(pin : int; statee : bool) returns (out : bool)
var s : int; i : int;
let
  out = true;
  i = Interface.change_pin_state(pin, statee);
  s = declare_once(pin, 1)
tel

node led_control_print(pin : int; statee : bool) returns (out : bool)
var d : bool; p : bool; s : int; i : int; v : bool; v_27 : int; v_28 : bool;
    v_29 : bool; v_30 : bool; v_31 : bool;
let
  out = true;
  p = Interface.print_int(v_27, v_31, true);
  v_31 = xor_node(statee, v_30);
  v_30 = if v_28 then false else v_29;
  v_29 = pre statee;
  v_28 = true fby false;
  v_27 = if statee then 105 else 66;
  d = if v then true else false;
  v = true fby false;
  i = Interface.change_pin_state(pin, statee);
  s = declare_once(pin, 1)
tel

node main returns (o : bool)
var period : int; on_off : bool; n : bool; m : bool; k : bool; j : int;
    i : bool; v : int; v_32 : int; v_33 : bool; v_34 : int; v_35 : bool;
let
  n = Interface.print_int(period, false, true);
  o = led_control(4, v_35);
  v_35 = Interface.read_pin_state(5);
  m = led_control(6, on_off);
  k = led(period, 3, true);
  i = led(v_34, 2, on_off);
  v_34 = Interface.random(8, 512);
  on_off = toggle_node(v_33);
  v_33 = Interface.read_pin_state(5);
  j = declare_once(5, 0);
  period = (v_32 + 1);
  v_32 = Interface.div(v, 64);
  v = Interface.read_analog(14)
tel

